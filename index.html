<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NovelAI to ComfyUI 프롬프트 변환기</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: #f0f2f5;
            color: #1c1e21;
            line-height: 1.6;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        .container {
            background-color: #ffffff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #4f46e5;
            margin-bottom: 20px;
        }
        textarea {
            width: 100%;
            height: 180px;
            padding: 10px;
            border: 1px solid #dddfe2;
            border-radius: 6px;
            box-sizing: border-box;
            margin-bottom: 10px;
            font-size: 14px;
        }
        button {
            display: block;
            width: 100%;
            padding: 12px;
            background-color: #4f46e5;
            color: #ffffff;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #4338ca;
        }
        .result-box {
            margin-top: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #606770;
        }
        .rules {
            background-color: #f7f8fa;
            border: 1px solid #dddfe2;
            border-radius: 6px;
            padding: 15px;
            margin-top: 25px;
        }
        .rules h2 {
            margin-top: 0;
            color: #1c1e21;
            font-size: 18px;
        }
        .rules h3 {
            margin-top: 15px;
            margin-bottom: 5px;
            font-size: 16px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 3px;
        }
        .rules ul {
            padding-left: 20px;
            margin: 0;
        }
        .rules li {
            margin-bottom: 8px;
        }
        code {
            background-color: #e4e6eb;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }

        /* --- Toggle Switch Styles --- */
        .toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            color: #606770;
            font-size: 14px;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
            margin: 0 10px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #4f46e5;
        }
        input:checked + .slider:before {
            transform: translateX(22px);
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>NovelAI to ComfyUI 프롬프트 변환기</h1>
        
        <div>
            <label for="novelai-prompt">NovelAI 프롬프트 입력:</label>
            <textarea id="novelai-prompt" placeholder="masterpiece, {{{hyper_detailed}}},
(emphasis), ((strong_emphasis)),
by_artist_name, a girl with (long hair, blue eyes)"></textarea>
        </div>

        <div class="toggle-container">
            <b>곱연산</b>
            <label class="switch">
                <input type="checkbox" id="calc-method-toggle">
                <span class="slider"></span>
            </label>
            <b>합연산</b>
        </div>
        
        <button id="convert-btn">변환하기</button>
        
        <div class="result-box">
            <label for="sd-prompt">ComfyUI 프롬프트 결과:</label>
            <textarea id="sd-prompt" readonly placeholder="변환된 프롬프트가 여기에 표시됩니다."></textarea>
        </div>
    </div>

    <div class="rules">
        <h2>변환 규칙 (ComfyUI용)</h2>
        
        <h3>기본 가중치 변환</h3>
        <ul>
            <li><code>(태그)</code> : 한 쌍의 소괄호는 형식 유지</li>
            <li><code>((태그))</code> : 두 쌍 이상의 소괄호는 가중치 1.1배 적용</li>
            <li><code>{태그}</code> : 가중치 1.05배 적용</li>
            <li><code>[태그]</code> : 가중치 1/1.05배 (약 0.95배) 적용</li>
            <li><b>계산 방식 토글:</b> 다중 괄호 계산 방식을 선택합니다.
                <ul>
                    <li><b>곱연산(기본):</b> <code>{{{tag}}}</code> → 1.05³ ≈ 1.16</li>
                    <li><b>합연산:</b> <code>{{{tag}}}</code> → 1 + (0.05 * 3) = 1.15</li>
                </ul>
            </li>
        </ul>
        
        <h3>특수 문법 변환</h3>
        <ul>
            <li><code>1.5::태그::</code> 형식은 <code>(태그:1.5)</code>로 변환됩니다.</li>
            <li><code>||태그1|태그2||</code> 형식은 프롬프트 교차 문법인 <code>[태그1|태그2]</code>로 변환됩니다.</li>
            <li><code>{태그1|태그2}</code> : 무작위 선택 문법으로 인식하여 그대로 유지됩니다.</li>
            <li><code>[from:to:when]</code> : 프롬프트 편집 문법으로 인식하여 그대로 유지됩니다.</li>
        </ul>

        <h3>텍스트 서식 자동 정리</h3>
        <ul>
            <li>태그에 포함된 언더바(<code>_</code>)는 공백으로 자동 치환됩니다. (예: <code>blue_sky</code> → <code>blue sky</code>)</li>
            <li><code>artist:</code> 또는 <code>by </code> 접두사는 제거됩니다.</li>
            <li><code>작가 (작품)</code> 형식의 태그는 <code>작가 \(작품\)</code>으로 변환됩니다.</li>
        </ul>
    </div>

    <script>
        document.getElementById('convert-btn').addEventListener('click', () => {
            const novelaiPrompt = document.getElementById('novelai-prompt').value;
            const isAdditive = document.getElementById('calc-method-toggle').checked;

            const lines = novelaiPrompt.split('\n');

            const processedLines = lines.map(line => {
                const hasTrailingComma = line.trim().endsWith(',');
                
                const tags = line.match(/(\([^)]*\)|\[[^\]]*\]|\{[^}]*\}|[^,])+/g) || [];

                const convertedTags = tags.map(rawTag => {
                    const tag = rawTag.trim();
                    if (!tag) return null;

                    // Rule for simple SD weight syntax like (tag) or ((tag))
                    const simpleWeightRegex = /^\s*(\(+)(.+?)(\)+)\s*$/;
                    const simpleWeightMatch = tag.match(simpleWeightRegex);
                    if (simpleWeightMatch && !simpleWeightMatch[2].includes(':')) {
                        const openBrackets = simpleWeightMatch[1];
                        const content = simpleWeightMatch[2].trim().replace(/_/g, ' ');
                        const closeBrackets = simpleWeightMatch[3];
                        const count = openBrackets.length;

                        if (openBrackets.length !== closeBrackets.length) { // Mismatched brackets
                            return tag; 
                        }

                        if (count === 1) { // Single pair: (tag) -> keep as is
                            return `(${content})`;
                        }
                        
                        if (count > 1) { // Multiple pairs: ((tag)) -> convert to (tag:weight)
                            let weight;
                            if (isAdditive) { // Additive: 1 + (0.1 * count)
                                weight = 1 + (0.1 * count);
                            } else { // Multiplicative: 1.1^count
                                weight = Math.pow(1.1, count);
                            }
                            return `(${content}:${weight.toFixed(2)})`;
                        }
                    }
                    
                    // Rule for (tag:weight)
                    const sdWeightRegex = /^\s*\((.+?):(-?\d+\.?\d*)\)\s*$/;
                    if (sdWeightRegex.test(tag)) {
                        return tag.replace(/_/g, ' ');
                    }

                    // Rule for [from:to:when]
                    const promptEditRegex = /^\[(.*?):(.*?):(\d+\.?\d*)\]$/;
                    if (promptEditRegex.test(tag)) {
                        return tag.replace(/_/g, ' ');
                    }

                    // Rule for {A|B|C}
                    const randomChoiceRegex = /^\{([^{}]*\|[^{}]*)\}$/;
                    const randomChoiceMatch = tag.match(randomChoiceRegex);
                    if (randomChoiceMatch) {
                        let content = randomChoiceMatch[1].split('|').map(t => t.trim().replace(/_/g, ' ')).join('|');
                        return `{${content}}`;
                    }

                    // Rule: 1.5::tag::
                    const weightRegex = /^(\d+\.?\d*)::(.*?)::$/;
                    const weightMatch = tag.match(weightRegex);
                    if (weightMatch) {
                        const weight = parseFloat(weightMatch[1]);
                        let content = weightMatch[2].trim().replace(/_/g, ' ').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
                        return `(${content}:${weight.toFixed(2)})`;
                    }

                    // Rule: ||tag1|tag2||
                    const crossPromptRegex = /^\|\|(.*?)\|\|$/;
                    const crossPromptMatch = tag.match(crossPromptRegex);
                    if (crossPromptMatch) {
                        let content = crossPromptMatch[1].split('|').map(t => t.trim().replace(/_/g, ' ')).join('|');
                        return `[${content}]`;
                    }

                    // NovelAI rules for {} and []
                    let content = tag;
                    let braceCount = 0;
                    let bracketCount = 0;

                    while (content.startsWith('{') && content.endsWith('}')) {
                        braceCount++;
                        content = content.substring(1, content.length - 1).trim();
                    }

                    while (content.startsWith('[') && content.endsWith(']')) {
                        bracketCount++;
                        content = content.substring(1, content.length - 1).trim();
                    }

                    content = content.replace(/_/g, ' ');

                    if (content.toLowerCase().startsWith('artist:')) {
                        content = content.substring(7).trim();
                    } else if (content.toLowerCase().startsWith('by ')) {
                        content = content.substring(3).trim();
                    }
                    
                    if (!content) return null;

                    if (braceCount === 0 && bracketCount === 0) {
                        // Not a NAI weight tag, just a regular tag. Escape if needed.
                        return content.replace(/\(/g, '\\(').replace(/\)/g, '\\)');
                    }

                    let weight;
                    if (isAdditive) {
                        weight = (braceCount > 0) ? 1 + (0.05 * braceCount) : 1 - (0.05 * bracketCount);
                    } else {
                        weight = (braceCount > 0) ? Math.pow(1.05, braceCount) : Math.pow(1 / 1.05, bracketCount);
                    }
                    
                    if (weight < 0) weight = 0;
                    
                    return `(${content.replace(/\(/g, '\\(').replace(/\)/g, '\\)')}:${weight.toFixed(2)})`;
                });

                let processedLine = convertedTags.filter(t => t !== null).join(', ');
                if (hasTrailingComma && processedLine) {
                    processedLine += ',';
                }
                return processedLine;
            });

            document.getElementById('sd-prompt').value = processedLines.join('\n');
        });
    </script>

</body>
</html>